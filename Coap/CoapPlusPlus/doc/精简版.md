
# NON
- 当消息不需要可靠传输（例如持续不断的读取一个传感器数据）时，可以发送NON的消息
- 在CoAP层，发送者没有任何办法得知NON类型的消息是否被接收端收到。
- 接收端必须不应答NON消息。如果缺少必要的上下文而无法正确的处理（包括消息是空的，使用了保留类别的code(1,6或7)，或者消息格式错误）那么接收端必须丢弃这个NON消息。同时服务端有可能会忽略该消息或者响应一个对应的RST消息。
- 对于NON的响应，接收端一般回应NON，但是也有可能是CON

# 去除重复消息机制
- 当ACK消息丢失或者在第一个超时时间之前没能到达原始服务端，接收端可能收到多次重复的CON消息(由Message ID和源端地址标识)。接收端应该对每一次收到的重复消息都回以相同的ACK或RST，但应该只处理一次。当CON消息传输的请求是幂等的时候，或者可以以幂等的方式来处理时，这一规则可以放宽。消息去除重复规则被放宽的例子如下：
    - 服务端对于幂等的请求的每一次重传都回以相同的响应（第4.2节），这样一来它就无需维护Message ID的状态，在此情况下可以放宽规则。例如，如果重复处理的过程的开销小于保留上一个响应的开销，实现中可能把GET,PUT,或DELETE请求的重传当作独立的请求来处理。
    - 对于一些非幂等的请求，只要在应用层语义上这个取舍是值得的，一些资源受限的服务器也可能会放宽规则。例如，如果一个POST请求对服务端的数据状态的影响是很短暂的，那么可能重复处理请求的开销会小于保留上一次传输的相同请求处理状态的开销。
接收端可能在NON_LIFETIME（第4.8.2节）时间内收到重复的NON消息（由Message ID和源端地址标识）。接收端应该忽略掉重复的NON消息，只处理一次。这一规则根据应用程序的语义，有可能被放宽。

# 拥塞控制 CoAP的基本拥塞控制由指数回退机制提供，见4.2节 。
- 为了避免拥塞，客户端（包括代理）应该严格限制他们同时与指定的服务器（包括代理）维持的未完成交互的数量（即NSTART值）。一个未完成的交互可以是一个仍在等待ACK的CON消息；也可以是一个在等待响应消息或者ACK的请求（这两种情况可以同时出现，做为同一个未完成的交互）。在本协议里NSTART的默认值为1.0